/**
 * Temple Stuart Accounting - Robinhood History Parser
 * CAREFUL PAIRING: Opens → Closes → Accurate Matching
 */

interface RobinhoodLeg {
  action: 'buy' | 'sell';
  symbol: string;
  strike: number;
  expiry: string;
  optionType: 'call' | 'put';
  position: 'open' | 'close';
  price: number;
  quantity: number;
  filledDate: string;
  filledTime: string;
}

interface RobinhoodSpread {
  strategyName: string;
  symbol: string;
  submitDate: string;
  legs: RobinhoodLeg[];
  isOpen: boolean;
}

interface PlaidTransaction {
  id: string;
  date: string;
  name: string;
  symbol: string;
  type: string;
  price: number;
  quantity: number;
  security?: {
    ticker_symbol?: string;
    option_underlying_ticker?: string;
    option_strike_price?: number;
    option_expiration_date?: string;
    option_contract_type?: string;
  };
}

interface MappingResult {
  txnId: string;
  tradeNum: string;
  strategy: string;
  coa: string;
  confidence: 'high' | 'medium' | 'low';
  matchedTo?: string;
}

interface TradeGroup {
  tradeNum: number;
  openSpread: RobinhoodSpread;
  closeLegs: RobinhoodLeg[];
}

export class RobinhoodHistoryParser {
  private tradeCounter = 1;

  parseHistory(historyText: string): RobinhoodSpread[] {
    const allSpreads: RobinhoodSpread[] = [];
    const lines = historyText.split('\n');
    
    let i = 0;
    while (i < lines.length) {
      const line = lines[i].trim();
      
      if (this.isSpreadHeader(line)) {
        const spread = this.parseSpread(lines, i);
        if (spread) {
          allSpreads.push(spread);
          i = spread.endIndex;
        }
      }
      i++;
    }
    
    const filledSpreads = allSpreads.filter(spread => {
      const hasFilledLegs = spread.legs.some(leg => leg.price > 0 && leg.filledDate);
      return hasFilledLegs;
    });
    
    return filledSpreads;
  }

  private isSpreadHeader(line: string): boolean {
    const spreadPatterns = [
      'Call Credit Spread',
      'Put Credit Spread',
      'Call Debit Spread',
      'Put Debit Spread',
      'Iron Condor',
      'Short Iron Condor',
      'Closing Call Credit Spread',
      'Closing Put Credit Spread',
      'Closing Call Debit Spread',
      'Closing Put Debit Spread',
      'Closing Iron Condor',
      'Closing Short Iron Condor'
    ];
    
    return spreadPatterns.some(pattern => line.includes(pattern));
  }

  private parseSpread(lines: string[], startIndex: number): (RobinhoodSpread & { endIndex: number }) | null {
    const headerLine = lines[startIndex].trim();
    const parts = headerLine.split(' ');
    const symbol = parts[0];
    const strategyType = headerLine.substring(symbol.length).trim();
    const submitDate = lines[startIndex + 1]?.trim() || '';
    
    const legs: RobinhoodLeg[] = [];
    let i = startIndex + 2;
    
    while (i < lines.length && i < startIndex + 50) {
      const line = lines[i].trim();
      
      if (this.isLegDefinition(line)) {
        const leg = this.parseLeg(lines, i);
        if (leg) {
          legs.push(leg);
        }
      }
      
      if (line.includes('Download Trade Confirmation') || 
          (i > startIndex + 5 && this.isSpreadHeader(line))) {
        break;
      }
      
      i++;
    }
    
    if (legs.length === 0) return null;
    
    const isOpen = legs[0].position === 'open';
    
    return {
      strategyName: strategyType,
      symbol,
      submitDate,
      legs,
      isOpen,
      endIndex: i
    };
  }

  private isLegDefinition(line: string): boolean {
    return /^(Buy|Sell)\s+[A-Z]+\s+\$[\d.]+\s+(Call|Put)\s+\d+\/\d+/.test(line);
  }

  private getNextNonEmptyLine(lines: string[], startIndex: number): string {
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.length > 0) return line;
    }
    return '';
  }

  private parseLeg(lines: string[], startIndex: number): RobinhoodLeg | null {
    const legLine = lines[startIndex].trim();
    const legMatch = legLine.match(/^(Buy|Sell)\s+([A-Z]+)\s+\$?([\d.]+)\s+(Call|Put)\s+([\d\/]+)/);
    if (!legMatch) return null;
    
    const [, action, symbol, strike, optionType, expiry] = legMatch;
    
    let price = 0;
    let quantity = 1;
    let filledDate = '';
    let filledTime = '';
    let position: 'open' | 'close' = 'open';
    
    for (let i = startIndex + 1; i < Math.min(startIndex + 20, lines.length); i++) {
      const line = lines[i].trim();
      
      if (line === 'Filled quantity') {
        const nextLine = this.getNextNonEmptyLine(lines, i + 1);
        const priceMatch = nextLine.match(/at\s+\$?([\d.]+)/);
        if (priceMatch) {
          price = parseFloat(priceMatch[1]);
        }
        
        const qtyMatch = nextLine.match(/^(\d+)\s+contract/);
        if (qtyMatch) quantity = parseInt(qtyMatch[1]);
      }
      
      if (line === 'Filled') {
        const nextLine = this.getNextNonEmptyLine(lines, i + 1);
        const dateMatch = nextLine.match(/([\d\/]+),\s*([\d:]+\s*[AP]M\s*\w+)/);
        if (dateMatch) {
          filledDate = dateMatch[1];
          filledTime = dateMatch[2];
        }
      }
      
      if (line === 'Position effect') {
        const posLine = this.getNextNonEmptyLine(lines, i + 1);
        position = posLine.toLowerCase().includes('close') ? 'close' : 'open';
      }
      
      if (i > startIndex + 1 && this.isLegDefinition(line)) break;
      if (line.includes('Download Trade Confirmation')) break;
    }
    
    return {
      action: action.toLowerCase() as 'buy' | 'sell',
      symbol,
      strike: parseFloat(strike),
      expiry,
      optionType: optionType.toLowerCase() as 'call' | 'put',
      position,
      price,
      quantity,
      filledDate,
      filledTime
    };
  }

  matchToPlaid(spreads: RobinhoodSpread[], plaidTransactions: PlaidTransaction[]): MappingResult[] {
    const mappings: MappingResult[] = [];
    
    const openSpreads = spreads.filter(s => s.isOpen);
    const closeSpreads = spreads.filter(s => !s.isOpen);
    
    console.log("STEP 1: Found " + openSpreads.length + " OPEN spreads, " + closeSpreads.length + " CLOSE spreads");
    
    const reversedOpens = [...openSpreads].reverse();
    
    const tradeGroups: TradeGroup[] = [];
    this.tradeCounter = 1;
    
    console.log("STEP 2: Pairing closes to opens...");
    for (const openSpread of reversedOpens) {
      const closeLegs = this.findAllMatchingCloseLegs(openSpread, closeSpreads);
      console.log("  Trade #" + this.tradeCounter + ": " + openSpread.symbol + " has " + closeLegs.length + " close legs");
      tradeGroups.push({ 
        tradeNum: this.tradeCounter++, 
        openSpread, 
        closeLegs 
      });
    }
    
    console.log("STEP 3: Mapping ALL legs to Plaid...");
    for (const group of tradeGroups) {
      const strategy = this.mapStrategy(group.openSpread.strategyName);
      const tradeNum = String(group.tradeNum);
      
      for (const leg of group.openSpread.legs) {
        if (leg.price === 0 || !leg.filledDate) continue;
        
        const match = this.findMatchingPlaidTxn(leg, plaidTransactions);
        const coa = this.assignCOA(leg);
        
        mappings.push({
          txnId: match?.id || '',
          tradeNum,
          strategy,
          coa,
          confidence: match ? 'high' : 'low',
          matchedTo: group.openSpread.symbol + " " + strategy
        });
        
        if (!match) {
          console.warn("  No Plaid match for OPEN: " + leg.symbol + " $" + leg.strike + " " + leg.optionType + " " + leg.action);
        }
      }
      
      for (const leg of group.closeLegs) {
        if (leg.price === 0 || !leg.filledDate) continue;
        
        const match = this.findMatchingPlaidTxn(leg, plaidTransactions);
        const coa = 'CLOSE';
        
        mappings.push({
          txnId: match?.id || '',
          tradeNum,
          strategy,
          coa,
          confidence: match ? 'high' : 'low',
          matchedTo: group.openSpread.symbol + " " + strategy + " close"
        });
        
        if (!match) {
          console.warn("  No Plaid match for CLOSE: " + leg.symbol + " $" + leg.strike + " " + leg.optionType + " " + leg.action);
        }
      }
    }
    
    console.log("STEP 4: Created " + mappings.length + " total mappings for " + tradeGroups.length + " trades");
    return mappings;
  }

  private findAllMatchingCloseLegs(openSpread: RobinhoodSpread, closeSpreads: RobinhoodSpread[]): RobinhoodLeg[] {
    const closeLegs: RobinhoodLeg[] = [];
    
    const openStrikes = openSpread.legs.map(l => l.strike).sort((a, b) => a - b);
    const openStrikesStr = openStrikes.join(',');
    
    for (const closeSpread of closeSpreads) {
      if ((closeSpread as any).matched) continue;
      
      if (closeSpread.symbol !== openSpread.symbol) continue;
      
      const closeStrikes = closeSpread.legs.map(l => l.strike).sort((a, b) => a - b);
      const closeStrikesStr = closeStrikes.join(',');
      
      if (openStrikesStr === closeStrikesStr) {
        (closeSpread as any).matched = true;
        closeLegs.push(...closeSpread.legs);
      }
    }
    
    return closeLegs;
  }

  private findMatchingPlaidTxn(leg: RobinhoodLeg, transactions: PlaidTransaction[]): PlaidTransaction | null {
    for (const txn of transactions) {
      if ((txn as any).mapped) continue;
      
      const txnSymbol = txn.security?.option_underlying_ticker || txn.security?.ticker_symbol || txn.symbol;
      if (txnSymbol !== leg.symbol) continue;
      
      const txnStrike = txn.security?.option_strike_price;
      if (!txnStrike || Math.abs(txnStrike - leg.strike) > 0.01) continue;
      
      if (Math.abs(txn.price - leg.price) > 0.50) continue;
      
      const txnType = txn.security?.option_contract_type;
      if (txnType !== leg.optionType) continue;
      
      if (txn.type !== leg.action) continue;
      
      const nameHasClose = txn.name?.toLowerCase().includes('close') || false;
      const matchesPosition = leg.position === 'close' ? nameHasClose : !nameHasClose;
      if (!matchesPosition) continue;
      
      const txnDate = new Date(txn.date);
      const legDate = this.parseRHDate(leg.filledDate);
      if (legDate) {
        const daysDiff = Math.abs((txnDate.getTime() - legDate.getTime()) / (1000 * 60 * 60 * 24));
        if (daysDiff > 4) continue; // Allow up to 4 days for weekend settlements (T+1 to T+3)
      }
      
      (txn as any).mapped = true;
      return txn;
    }
    
    return null;
  }

  private parseRHDate(rhDate: string): Date | null {
    const match = rhDate.match(/(\d+)\/(\d+)/);
    if (!match) return null;
    const month = parseInt(match[1]) - 1;
    const day = parseInt(match[2]);
    const year = 2025;
    return new Date(year, month, day);
  }

  private assignCOA(leg: RobinhoodLeg): string {
    if (leg.position === 'close') {
      return 'CLOSE';
    }
    
    if (leg.action === 'buy') {
      return leg.optionType === 'call' ? 'T-1200' : 'T-1210';
    } else {
      // All short options (calls and puts) use T-2100
      return 'T-2100';
    }
  }

  private mapStrategy(rhStrategy: string): string {
    const strategyMap: Record<string, string> = {
      'Call Credit Spread': 'call-credit',
      'Put Credit Spread': 'put-credit',
      'Call Debit Spread': 'call-debit',
      'Put Debit Spread': 'put-debit',
      'Iron Condor': 'iron-condor',
      'Short Iron Condor': 'iron-condor',
      'Closing Call Credit Spread': 'call-credit',
      'Closing Put Credit Spread': 'put-credit',
      'Closing Call Debit Spread': 'call-debit',
      'Closing Put Debit Spread': 'put-debit',
    };
    
    if (strategyMap[rhStrategy]) {
      return strategyMap[rhStrategy];
    }
    
    for (const [key, value] of Object.entries(strategyMap)) {
      if (rhStrategy.includes(key)) {
        return value;
      }
    }
    
    if (rhStrategy.toLowerCase().includes('call')) {
      return rhStrategy.toLowerCase().includes('credit') ? 'call-credit' : 'call-debit';
    }
    if (rhStrategy.toLowerCase().includes('put')) {
      return rhStrategy.toLowerCase().includes('credit') ? 'put-credit' : 'put-debit';
    }
    
    return 'long-call';
  }

  resetCounter() {
    this.tradeCounter = 1;
  }
}

export const robinhoodParser = new RobinhoodHistoryParser();

export async function fetchRobinhoodHistory(): Promise<string> {
  const response = await fetch('/api/robinhood/get-history');
  if (!response.ok) throw new Error('Failed to fetch history');
  const data = await response.json();
  return data.historyText || '';
}
