/**
 * Temple Stuart Accounting - Robinhood History Parser v7.0
 * NEW: Sequential open-then-close matching
 */

interface RobinhoodLeg {
  action: 'buy' | 'sell';
  symbol: string;
  strike: number;
  expiry: string;
  optionType: 'call' | 'put';
  position: 'open' | 'close';
  price: number;
  quantity: number;
  filledDate: string;
  filledTime: string;
}

interface RobinhoodSpread {
  strategyName: string;
  symbol: string;
  submitDate: string;
  limitPrice: number;
  legs: RobinhoodLeg[];
  isOpen: boolean;
}

interface PlaidTransaction {
  id: string;
  date: string;
  name: string;
  symbol: string;
  type: string;
  subtype?: string;
  price: number;
  quantity: number;
  amount: number;
  security?: {
    ticker_symbol?: string;
    option_underlying_ticker?: string;
    option_strike_price?: number;
    option_expiration_date?: string;
    option_contract_type?: string;
  };
}

interface MappingResult {
  txnId: string;
  tradeNum: string;
  strategy: string;
  coa: string;
  confidence: 'high' | 'medium' | 'low';
  matchedTo?: string;
}

class RobinhoodHistoryParser {
  private tradeCounter: number = 1;

  parseHistory(historyText: string): RobinhoodSpread[] {
    try {
      const lines = historyText.split('\n').map(l => l.trim()).filter(l => l);
      const spreads: RobinhoodSpread[] = [];
      
      console.log(`üìÑ Parsing ${lines.length} lines from history...`);
      
      let i = 0;
      while (i < lines.length) {
        const line = lines[i];
        
        const strategyMatch = line.match(/^([A-Z]{2,5})\s+(.+(?:Credit Spread|Debit Spread|Short Iron Condor|Iron Condor|Long Call|Short Call|Long Put|Short Put|2-Option Order))$/i);
        
        if (strategyMatch) {
          const symbol = strategyMatch[1];
          const strategyName = strategyMatch[2];
          
          i++;
          const submitDate = lines[i] || '';
          
          i++;
          const limitPriceLine = lines[i] || '';
          const limitPriceMatch = limitPriceLine.match(/^\$?([\d.]+)$/);
          const limitPrice = limitPriceMatch ? parseFloat(limitPriceMatch[1]) : 0;
          
          const legs: RobinhoodLeg[] = [];
          
          let verifiedLimitPrice = limitPrice;
          for (let j = i; j < Math.min(i + 30, lines.length); j++) {
            if (lines[j] === 'Limit price' && j + 1 < lines.length) {
              const lpMatch = lines[j + 1].match(/^\$?([\d.]+)$/);
              if (lpMatch) {
                verifiedLimitPrice = parseFloat(lpMatch[1]);
                break;
              }
            }
          }
          
          while (i < lines.length) {
            const currentLine = lines[i];
            
            if (currentLine.match(/^([A-Z]{2,5})\s+(.+(?:Credit Spread|Debit Spread|Iron Condor|Long Call|Short Call|Long Put|Short Put|2-Option Order))/i)) break;
            if (currentLine === 'Download Trade Confirmation') {
              i++;
              break;
            }
            if (currentLine === 'Older' || currentLine === 'Recent') break;
            
            const legMatch = currentLine.match(/^(Buy|Sell)\s+([A-Z]{2,5})\s+\$?([\d.]+)\s+(Call|Put)\s+([\d\/]+)$/i);
            
            if (legMatch) {
              const action = legMatch[1].toLowerCase() as 'buy' | 'sell';
              const legSymbol = legMatch[2];
              const strike = parseFloat(legMatch[3]);
              const optionType = legMatch[4].toLowerCase() as 'call' | 'put';
              const expiry = legMatch[5];
              
              let position: 'open' | 'close' = 'open';
              let price = 0;
              let quantity = 1;
              let filledDate = '';
              let filledTime = '';
              
              for (let j = i + 1; j < Math.min(i + 25, lines.length); j++) {
                const scanLine = lines[j];
                
                if (scanLine === 'Position effect') {
                  const posEffect = lines[j + 1] || '';
                  position = posEffect.toLowerCase().includes('close') ? 'close' : 'open';
                }
                
                const qtyMatch = scanLine.match(/^([\d]+)\s+contracts?\s+at\s+\$?([\d.]+)$/i);
                if (qtyMatch) {
                  quantity = parseInt(qtyMatch[1]);
                  price = parseFloat(qtyMatch[2]);
                }
                
                const dateMatch = scanLine.match(/^(\d+\/\d+),\s+(\d+:\d+\s+[AP]M)/i);
                if (dateMatch) {
                  filledDate = dateMatch[1];
                  filledTime = dateMatch[2];
                  break;
                }
                
                if (scanLine.match(/^(Buy|Sell)\s+([A-Z]{2,5})\s+\$/)) break;
              }
              
              if (price > 0 && filledDate) {
                legs.push({
                  action,
                  symbol: legSymbol,
                  strike,
                  expiry,
                  optionType,
                  position,
                  price,
                  quantity,
                  filledDate,
                  filledTime
                });
              }
            }
            
            i++;
          }
          
          if (legs.length > 0) {
            const isOpen = legs.every(leg => leg.position === 'open');
            
            spreads.push({
              strategyName,
              symbol,
              submitDate,
              limitPrice: verifiedLimitPrice,
              legs,
              isOpen
            });
          }
          
          continue;
        }
        
        i++;
      }
      
      spreads.reverse();
      
      console.log(`‚úÖ Parsed ${spreads.length} spreads (chronological)`);
      return spreads;
      
    } catch (error) {
      console.error('‚ùå Parse error:', error);
      return [];
    }
  }

  matchToPlaid(spreads: RobinhoodSpread[], plaidTransactions: PlaidTransaction[]): MappingResult[] {
    try {
      console.log(`\nüîç MATCHING ${spreads.length} spreads to ${plaidTransactions.length} Plaid txns`);
      
      if (spreads.length === 0) return [];
      
      const results: MappingResult[] = [];
      const unmapped = plaidTransactions.filter(t => !(t as any).mapped);
      
      // PHASE 1: Map all OPEN positions first
      console.log(`\nüìä PHASE 1: Mapping OPEN positions`);
      const openSpreads = spreads.filter(s => s.isOpen);
      
      for (const spread of openSpreads) {
        const tradeNum = this.tradeCounter++;
        console.log(`\nüéØ Trade #${tradeNum}: OPEN ${spread.symbol} ${spread.strategyName}`);
        console.log(`   Limit: $${spread.limitPrice}, Legs: ${spread.legs.length}`);
        
        const matches = this.matchSpreadLegs(spread, unmapped, tradeNum);
        
        if (matches.length > 0) {
          results.push(...matches);
          console.log(`   ‚úÖ Mapped ${matches.length} legs`);
        } else {
          console.log(`   ‚ö†Ô∏è No match found`);
        }
      }
      
      console.log(`\nüìä PHASE 1 COMPLETE: ${results.length} open legs mapped`);
      
      // PHASE 2: Map all CLOSE positions
      console.log(`\nüìä PHASE 2: Mapping CLOSE positions`);
      const closeSpreads = spreads.filter(s => !s.isOpen);
      
      // Build reverse lookup: strikes/expiry/type -> trade number
      const positionMap = new Map<string, number>();
      
      for (const result of results) {
        const key = result.matchedTo || '';
        if (key && !positionMap.has(key)) {
          positionMap.set(key, parseInt(result.tradeNum));
        }
      }
      
      for (const spread of closeSpreads) {
        // Find matching open trade number by comparing strikes
        let tradeNum = this.tradeCounter;
        
        for (const leg of spread.legs) {
          const posKey = `${spread.symbol} ${leg.strike} ${leg.optionType}`;
          if (positionMap.has(posKey)) {
            tradeNum = positionMap.get(posKey)!;
            break;
          }
        }
        
        // If no match found, assign new trade number
        if (tradeNum === this.tradeCounter) {
          this.tradeCounter++;
        }
        
        console.log(`\nüéØ Trade #${tradeNum}: CLOSE ${spread.symbol} ${spread.strategyName}`);
        console.log(`   Limit: $${spread.limitPrice}, Legs: ${spread.legs.length}`);
        
        const matches = this.matchSpreadLegs(spread, unmapped, tradeNum);
        
        if (matches.length > 0) {
          results.push(...matches);
          console.log(`   ‚úÖ Mapped ${matches.length} legs`);
        } else {
          console.log(`   ‚ö†Ô∏è No match found`);
        }
      }
      
      console.log(`\n‚úÖ FINAL: Mapped ${results.length} transactions across ${this.tradeCounter - 1} trades`);
      return results;
      
    } catch (error) {
      console.error('‚ùå Matching error:', error);
      return [];
    }
  }

  private matchSpreadLegs(
    spread: RobinhoodSpread,
    plaidTxns: PlaidTransaction[],
    tradeNum: number
  ): MappingResult[] {
    const { symbol, limitPrice, legs } = spread;
    
    const dateGroups = new Map<string, PlaidTransaction[]>();
    
    for (const txn of plaidTxns) {
      if ((txn as any).mapped) continue;
      
      const txnSymbol = txn.security?.option_underlying_ticker || txn.symbol;
      if (txnSymbol !== symbol) continue;
      
      const dateKey = txn.date.substring(0, 10);
      if (!dateGroups.has(dateKey)) {
        dateGroups.set(dateKey, []);
      }
      dateGroups.get(dateKey)!.push(txn);
    }
    
    for (const [date, txns] of dateGroups) {
      if (txns.length < legs.length) continue;
      
      const combinations = this.getCombinations(txns, legs.length);
      
      for (const combo of combinations) {
        const firstQty = combo[0]?.quantity || 1;
        const allSameQty = combo.every(t => t.quantity === firstQty);
        
        if (!allSameQty) continue;
        
        const totalAmount = Math.abs(combo.reduce((sum, t) => sum + t.amount, 0));
        const perContractAmount = totalAmount / firstQty;
        
        const priceDiff = Math.abs(perContractAmount - limitPrice);
        
        if (priceDiff > 0.10) continue;
        
        console.log(`   üí∞ Found group: qty=${firstQty}, total=$${totalAmount.toFixed(2)}, per-contract=$${perContractAmount.toFixed(2)} (target: $${limitPrice})`);
        
        const matches: Array<{ leg: RobinhoodLeg; txn: PlaidTransaction }> = [];
        
        for (const leg of legs) {
          const matchingTxn = combo.find(txn => this.legMatchesTxn(leg, txn));
          
          if (!matchingTxn) {
            console.log(`   ‚ùå No match for leg: ${leg.action} ${leg.strike} ${leg.optionType}`);
            break;
          }
          
          matches.push({ leg, txn: matchingTxn });
        }
        
        if (matches.length === legs.length) {
          console.log(`   ‚úÖ All ${legs.length} legs matched!`);
          
          const results: MappingResult[] = [];
          
          for (const { leg, txn } of matches) {
            results.push({
              txnId: txn.id || (txn as any).investment_transaction_id,
              tradeNum: tradeNum.toString(),
              strategy: this.mapStrategy(spread.strategyName),
              coa: this.assignCOA(leg),
              confidence: 'high',
              matchedTo: `${symbol} ${leg.strike} ${leg.optionType}`
            });
            
            (txn as any).mapped = true;
          }
          
          return results;
        }
      }
    }
    
    console.log(`   ‚ö†Ô∏è No valid match found`);
    return [];
  }

  private legMatchesTxn(leg: RobinhoodLeg, txn: PlaidTransaction): boolean {
    const txnStrike = txn.security?.option_strike_price;
    if (!txnStrike || Math.abs(txnStrike - leg.strike) > 0.01) return false;
    
    const txnOptionType = txn.security?.option_contract_type?.toLowerCase();
    if (txnOptionType !== leg.optionType) return false;
    
    const txnAction = txn.type?.toLowerCase();
    if (txnAction !== leg.action) return false;
    
    const nameHasClose = txn.name?.toLowerCase().includes('to close') || false;
    const matchesPosition = leg.position === 'close' ? nameHasClose : !nameHasClose;
    if (!matchesPosition) return false;
    
    const txnPerContractPrice = Math.abs(txn.price);
    if (Math.abs(txnPerContractPrice - leg.price) > 0.50) return false;
    
    if (txn.quantity !== leg.quantity) return false;
    
    const rhExpiry = this.parseRHExpiry(leg.expiry);
    const plaidExpiry = this.parsePlaidExpiry(txn.security?.option_expiration_date || '');
    
    if (rhExpiry && plaidExpiry) {
      const daysDiff = Math.abs((rhExpiry.getTime() - plaidExpiry.getTime()) / (1000 * 60 * 60 * 24));
      if (daysDiff > 2) return false;
    }
    
    return true;
  }

  private parseRHExpiry(expiry: string): Date | null {
    const match = expiry.match(/(\d+)\/(\d+)/);
    if (!match) return null;
    
    const month = parseInt(match[1]) - 1;
    const day = parseInt(match[2]);
    const year = 2025;
    
    return new Date(year, month, day);
  }

  private parsePlaidExpiry(expiry: string): Date | null {
    if (!expiry) return null;
    
    if (expiry.match(/\d{4}-\d{2}-\d{2}/)) {
      return new Date(expiry);
    }
    
    const match = expiry.match(/([A-Za-z]+)\s+(\d+),\s+(\d+)/);
    if (!match) return null;
    
    const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
    const month = monthNames.indexOf(match[1].toLowerCase().substring(0, 3));
    const day = parseInt(match[2]);
    const year = 2000 + parseInt(match[3]);
    
    if (month === -1) return null;
    
    return new Date(year, month, day);
  }

  private getCombinations<T>(arr: T[], size: number): T[][] {
    if (size > arr.length) return [];
    if (size === arr.length) return [arr];
    if (size === 1) return arr.map(item => [item]);
    
    const result: T[][] = [];
    
    for (let i = 0; i <= arr.length - size; i++) {
      const head = arr[i];
      const tailCombos = this.getCombinations(arr.slice(i + 1), size - 1);
      for (const combo of tailCombos) {
        result.push([head, ...combo]);
      }
    }
    
    return result;
  }

  private assignCOA(leg: RobinhoodLeg): string {
    if (leg.position === 'close') {
      return 'T-4100';
    }
    
    if (leg.action === 'buy') {
      return leg.optionType === 'call' ? 'T-1200' : 'T-1210';
    } else {
      return leg.optionType === 'call' ? 'T-2100' : 'T-2110';
    }
  }
  
  private mapStrategy(rhStrategy: string): string {
    if (rhStrategy.includes('Credit')) return rhStrategy.includes('Call') ? 'call-credit' : 'put-credit';
    if (rhStrategy.includes('Debit')) return rhStrategy.includes('Call') ? 'call-debit' : 'put-debit';
    if (rhStrategy.includes('Iron Condor')) return 'iron-condor';
    if (rhStrategy.includes('Long Call')) return 'long-call';
    if (rhStrategy.includes('Short Call')) return 'short-call';
    if (rhStrategy.includes('Long Put')) return 'long-put';
    if (rhStrategy.includes('Short Put')) return 'short-put';
    
    return 'long-call';
  }

  resetCounter() {
    this.tradeCounter = 1;
  }
}

export const robinhoodParser = new RobinhoodHistoryParser();

export async function fetchRobinhoodHistory(): Promise<string> {
  const response = await fetch('/api/robinhood/get-history');
  if (!response.ok) throw new Error('Failed to fetch history');
  const data = await response.json();
  return data.historyText || '';
}
